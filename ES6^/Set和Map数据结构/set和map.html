<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <script>
      //   const s = new Set();
      //   [2, 3, 5, 4, 4, 5, 2, 2].forEach((x) => s.add(x));
      //   for (let i of s) {
      //     console.log(i);
      //   }

      //Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化
      //   const set = new Set([1, 2, 3, 4, 5, 4, 5]);
      //   console.log(...set);

      //   const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
      //   console.log(items.size);

      //   const set = new Set(document.querySelectorAll("div"));
      //   console.log(set.size);

      //去除数组的重复成员
      //   let array = [1, 2, 3, 4, 3, 1, 2, 3, 5, 4];
      //   console.log([...new Set(array)]);

      //去除字符串里面的重复字符
      //   let a = [...new Set("abbbsdgsdf")].join("");
      //   console.log(a);

      //去除数组重复成员方法2
      //   function dedupe(array) {
      //     return Array.from(new Set(array));
      //   }
      //   dedupe([1, 1, 3, 2]);

      //向 Set 加入值的时候，不会发生类型转换
      //Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===）
      //   主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。

      //判断是否包括一个键在上面
      //   const properties = new Set();
      //   properties.add("width");
      //   properties.add("height");

      //   if (properties.has("width")) {
      //     console.log("width");
      //   }

      //Set结构键名和键值一样，keys和values方法行为一致
      //   let set = new Set(["red", "green", "blue"]);

      //   for (let item of set.keys()) {
      //     console.log(item);
      //   }

      //   for (let item of set.values()) {
      //     console.log(item);
      //   }

      //   for (let item of set.entries()) {
      //     console.log(item);
      //   }

      //Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法
      //   Set.prototype[Symbol.iterator] === Set.prototype.values;

      //并集、交集和差集
      //   let a = new Set([1, 2, 3]);
      //   let b = new Set([3, 4, 5]);

      //   let union = new Set([...a, ...b]);

      //   let intersect = new Set([...a].filter((x) => b.hsa(x)));

      //   let difference = new Set([...a].filter((x) => !b.has(x)));

      //在遍历操作中同步改变原来的set结构
      //方法一
      //   let set = new Set([1, 2, 3]);
      //   set = new Set([...set].map((val) => val * 2));

      //方法二
      //   let set = new Set([1, 2, 3]);
      //   set = new Set(Array.from(set, (val) => val * 2));
      //   console.log(set);

      //WeakSet的成员只能是对象；
      //对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用
      //WeakSet不可遍历

      //WeakSet例子
      //   const foos = new WeakSet();
      //   class Foo {
      //     constructor() {
      //       foos.add(this);
      //     }

      //     method() {
      //       if (!foos.has(this)) {
      //         throw new TypeError("Foo.prototype.mehtod 只能在Foo的实例上调用!");
      //       }
      //     }
      //   }

      //   Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应
      //Map接受数组作为参数
      //   const map = new Map([
      //     ["name", "张三"],
      //     ["title", "Author"],
      //   ]);

      //   map.size;
      //   map.has("name");
      //   map.get("name");
      //   map.has("title");
      //   map.get("title");

      //实际算法
      //   const items = [
      //     ["name", "张三"],
      //     ["title", "Author"],
      //   ];

      //   const map = new Map();

      //   items.forEach(([key, value]) => map.set(key, value));

      //   const set = new Set([
      //     ["foo", 1],
      //     ["bar", 2],
      //   ]);
      //   const m1 = new Map(set);
      //   m1.get("foo");

      //   const m2 = new Map([["baz", 3]]);
      //   const m3 = new Map(m2);
      //   m3.get("baz");

      //只有对同一个对象的引用，Map 结构才将其视为同一个键
      //Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键
      //如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键
      //   const map = new Map();
      //   map.set(["a"], 555);
      //   console.log(map.get(["a"]));

      //Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法
      //   map[Symbol.iterator] === map.entries;

      //   [...mapkeys()];
      //   [...map.values()];
      //   [...map.entries()];
      //   [...map];

      //结合map方法、filter方法
      //   const map0 = new Map().set(1, "a").set(2, "b").set(3, "c");
      //   const map1 = new Map([...map0].filter((k, v) => k < 3));

      //   const map2 = new Map([...map0].map(([k, v]) => [k * 2, "_" + v]));

      //   map.foreach((value, key, map) => {
      //     console.log("key: %s", "value: %s", key, vlaue);
      //   });

      //Map转数组
      //数组转Map

      //Map转对象
      //   function strMapToObj(strMap) {
      //     let obj = Obj.create(null);
      //     for (let [k, v] of strMap) {
      //       obj[k] = v;
      //     }
      //     return obj;
      //   }
      //   const myMap = new Map().set("yes", true).set("no", false);
      //   strMapToObj(myMap);

      //对象转Map
      //   let obj = { a: 1, b: 2 };
      //   let map = new Map(Object.entries(obj));

      //转换函数
      //   function objToStrMap(obj) {
      //     let strMap = new Map();
      //     for (let k of Object.keys(obj)) {
      //       strMap.set(k, obj[k]);
      //     }
      //     return strMap;
      //   }
      //   objToStrMap({ yes: true, no: false });

      //Map转JSON
      //键名都是字符串
      //   function strMapToJson(strMap) {
      //       return JSON.stringify(strMapToObj(strMap))
      //   }

      //   let myMap = new Map().set('yes', true).set('no', false)
      //   strMapToJson(myMap)

      //键名有非字符串
      //   function mapToArrayJson(map) {
      //     return JSON.stringify([...map]);
      //   }
      //   let myMap = new Map().set(true, 7).set({ foo: 3 }, ["abc"]);
      //   mapToArrayJson(myMap);

      //JSON转Map
      //所有键名都是字符串
      //   function jsonToStrMap(jsonStr) {
      //     return objToStrMap(JSON.parse(jsonStr));
      //   }

      //   jsonToStrMap('{"yes": true, "no": false}');

      //整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组
      function jsonToMap(jsonStr) {
        return new Map(JSON.parse(jsonStr));
      }
      jsonToMap('[[true, 7],[{"foo":3}, ["abc"]]');
    </script>
  </body>
</html>
